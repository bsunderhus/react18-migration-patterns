# id: subscribe-in-render-unsubscribe-in-effect-cleanup

- Problem: React component (or hook) render code (body or useMemo) should not create subscriptions (`.subscribe(...)` method invocation) that requires unsubscription (`.unsubscribe()` method invocation).
- Solution: Subscribe in effect hook AND unsubscribe in the SAME effect hook's cleanup function.
- Why: React concurrent mode can execute code in a component's render then throw away the result without ever calling effect hooks, leading to subscriptions that are never cleaned up as their references are lost.

### Anti-pattern: Subscribe in render body and unsubscribe in effect cleanup

âŒ Issue - The subscribe/unsubscribe are split between render code and effect cleanup code which will get out of sync in concurrent mode.

```tsx
const Component = () => {
  // ... render code
  subscriptionRef.current = someService.subscribe(/*...*/);
  // ... render code
  React.useEffect(() => { // or useLayoutEffect/useInsertionEffect
    return () => subscriptionRef.current?.unsubscribe();
  }, []);
};
```

âœ… Solution - Move the subscription inside effect so the pairs of subscribe/unsubscribe are always matched.

```tsx
const Component = () => {
  // ... render code
  React.useEffect(() => { // or useLayoutEffect/useInsertionEffect
    subscriptionRef.current = someService.subscribe(/*...*/);
    return () => subscriptionRef.current?.unsubscribe();
  }, []);
};
```

### Anti-pattern: Subscribe in useMemo and unsubscribe in effect cleanup

âŒ Issue - The subscribe/unsubscribe are split between useMemo and effect cleanup code which will get out of sync in concurrent mode.

```tsx
const Component = (props) => {
  // ... render code
  const subscription = React.useMemo(() => someService.subscribe(/*...*/), []);
  // ...
  // or useLayoutEffect/useInsertionEffect
  React.useEffect(() => {
    return () => subscription.unsubscribe();
  }, []);
};
```

âœ… Solution - Move the subscription inside the same effect hook.

```tsx
const Component = (props) => {
  // or useLayoutEffect/useInsertionEffect
  React.useEffect(() => {
    const subscription = someService.subscribe(/*...*/)
    return () => subscription.unsubscribe();
  }, []);
};
```

### Anti-pattern: Subscription probably created in render, unsubscribe in effect cleanup


âŒ Issue - Even if there's no direct call in render to a `.subscribe(...)` (in this case SomeService might be creating a subscription internally), the `.unsubscribe()` is still separated from the subscription creation which can lead to issues in concurrent mode.

```tsx
const Component = (props) => {
  // ... render code
  const someService = React.useMemo(() => new SomeService(/* ... */), []);
  // ...
  React.useEffect(() => { // or useLayoutEffect/useInsertionEffect
    return () => someService.unsubscribe();
  }, []);
};
```

âœ… Solution - Move the subscribe and unsubscribe into the same effect hook.

```tsx
const Component = (props) => {
  // or useLayoutEffect/useInsertionEffect
  React.useEffect(() => {
    const someService = new SomeService(/* ... */)
    return () => someService.unsubscribe();
  }, []);
};
```

### OK-Pattern: Subscribe in body without unsubscribe

> ðŸ¤– *For Humans only*: This is an anti-pattern overall, you should avoid this pattern in general. However, in concurrent mode, this pattern's behavior does not change because the subscription is created every render and has no cleanup. In Strict Mode, this code is double-invoked but the first subscription is never cleaned up, and the second subscription is created and also never cleaned up, if you're counting on rendering only once to create a single subscription, this will break in Strict Mode.

âœ… OK as-is - The current code subscribes every render and is already called multiple times and has no clean up. Concurrent mode will not change its behavior.

```tsx
const Component = () => {
  someService.subscribe(/*...*/);
};
```

### OK-Pattern: Subscribe in useMemo without unsubscribe

> ðŸ¤– *For Humans only*: This is an anti-pattern overall, you should avoid this pattern in general. However, in concurrent mode, this pattern's behavior does not change because the subscription is created every render and has no cleanup. In Strict Mode, this code is double-invoked but the first subscription is never cleaned up, and the second subscription is created and also never cleaned up, if you're counting on rendering only once to create a single subscription, this will break in Strict Mode.

âœ… OK as-is - The current code subscribes twice in useMemo and has no clean up. Concurrent mode will not change its behavior.

```tsx
const Component = () => {
  React.useMemo(() => {
    someService.subscribe(/*...*/);
  }, []);
};
```