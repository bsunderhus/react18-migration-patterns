import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Anti-patterns/Subscribe in render, unsubscribe in effect cleanup" />

## id: subscribe-in-render-unsubscribe-in-effect-cleanup

- Problem: React component (or hook) render code (body or useMemo) should not create subscriptions (`.subscribe(...)` method invocation) that requires unsubscription (`.unsubscribe()` method invocation).
- Solution: Subscribe in effect hook AND unsubscribe in the SAME effect hook's cleanup function.
- Why: In React Concurrent mode, if you have a subscription that requires cleanup, both the subscription and its cleanup must be collocated in the same effect hook. If they are separated, React may call the render code multiple times without calling the cleanup, leading to memory leaks or unexpected behavior.

Before classifying code as this pattern, ALL conditions must be met:

âŒ Anti-pattern Conditions:

1. Subscription happens in render code (component body or useMemo)
2. Unsubscription happens in an effect CLEANUP function (return statement)
3. Both subscription AND unsubscription methods exist in the code
4. The subscription and cleanup are SEPARATED (not in the same effect)

If ANY of these conditions are met, then it is NOT this pattern.

âœ… Ok-as-is Conditions:

- No unsubscription method exists at all
- Unsubscription happens in effect body (not cleanup function)
- Subscription and unsubscription are already in the same effect and cleanup
- Only creation exists without cleanup, or only cleanup exists without creation

### Anti-pattern: Subscribe in render body and unsubscribe in effect cleanup

âŒ Issue - The subscribe/unsubscribe are split between render code and effect cleanup code which will get out of sync in concurrent mode.

```tsx
const Component = () => {
  // ... render code
  subscriptionRef.current = someService.subscribe(/*...*/);
  // ... render code
  React.useEffect(() => {
    // or useLayoutEffect/useInsertionEffect
    return () => subscriptionRef.current?.unsubscribe();
  }, []);
};
```

âœ… Solution - Move the subscription inside effect so the pairs of subscribe/unsubscribe are always matched.

```tsx
const Component = () => {
  // ... render code
  React.useEffect(() => {
    // or useLayoutEffect/useInsertionEffect
    subscriptionRef.current = someService.subscribe(/*...*/);
    return () => subscriptionRef.current?.unsubscribe();
  }, []);
};
```

### Anti-pattern: Subscribe in useMemo and unsubscribe in effect cleanup

âŒ Issue - The subscribe/unsubscribe are split between useMemo and effect cleanup code which will get out of sync in concurrent mode.

```tsx
const Component = (props) => {
  // ... render code
  const subscription = React.useMemo(() => someService.subscribe(/*...*/), []);
  // ...
  // or useLayoutEffect/useInsertionEffect
  React.useEffect(() => {
    return () => subscription.unsubscribe();
  }, []);
};
```

âœ… Solution - Move the subscription inside the same effect hook.

```tsx
const Component = (props) => {
  // or useLayoutEffect/useInsertionEffect
  React.useEffect(() => {
    const subscription = someService.subscribe(/*...*/);
    return () => subscription.unsubscribe();
  }, []);
};
```

### Anti-pattern: Subscription probably created in render, unsubscribe in effect cleanup

âŒ Issue - Even if there's no direct call in render to a `.subscribe(...)` (in this case SomeService might be creating a subscription internally), the `.unsubscribe()` is still separated from the subscription creation which can lead to issues in concurrent mode.

```tsx
const Component = (props) => {
  // ... render code
  const someService = React.useMemo(() => new SomeService(/* ... */), []);
  // ...
  React.useEffect(() => {
    // or useLayoutEffect/useInsertionEffect
    return () => someService.unsubscribe();
  }, []);
};
```

âœ… Solution - Move the subscribe and unsubscribe into the same effect hook.

```tsx
const Component = (props) => {
  // or useLayoutEffect/useInsertionEffect
  React.useEffect(() => {
    const someService = new SomeService(/* ... */);
    return () => someService.unsubscribe();
  }, []);
};
```

### OK-Pattern: Subscribe in body without unsubscribe

> ðŸ¤– *For Humans only*: Most of the time is not a good idea to have subscriptions without proper clean up.

âœ… OK as-is - The current code subscribes every render and is already called multiple times and has no clean up. Concurrent mode will not change its behavior.

```tsx
const Component = () => {
  someService.subscribe(/*...*/);
};
```

### OK-Pattern: Subscribe in useMemo without unsubscribe

> ðŸ¤– *For Humans only*: Most of the time is not a good idea to have subscriptions without proper clean up.

âœ… OK as-is - The current code subscribes twice in useMemo and has no clean up. Concurrent mode will not change its behavior.

```tsx
const Component = () => {
  React.useMemo(() => {
    someService.subscribe(/*...*/);
  }, []);
};
```

### OK-Pattern: Subscribe in render and unsubscribe in effect body

> ðŸ¤– *For Humans only*: This will generate subscriptions that might possibly be cleaned up before expected
> It is problematic but will not lead to lost cleanups in concurrent mode. 

âœ… OK as-is - The current code subscribes in render and unsubscribes in effect body. Although not ideal, concurrent mode will not lead to lost cleanups since the unsubscribe is not in cleanup function.

```tsx
const Component = () => {
  someService.subscribe(/*...*/);
  React.useEffect(() => {
    // or useLayoutEffect/useInsertionEffect
    someService.unsubscribe();
  }, []);
};
```
